[{"name":"app.R","content":"#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    http://shiny.rstudio.com/\n#\n\n# I put everything into one file for easier deployment\n# code is sourced from my main project\n\n# required libraries\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(waiter)\nlibrary(metaheuristicOpt)\n\n################################################################################\n# Global variables for app\n################################################################################\nmodels = c(\n  \"Logistic\",\n  \"Log-logistic\",\n  \"Probit\",\n  \"Log-probit\",\n  \"Weibull\",\n  \"Multistage 1\",\n  \"Multistage 2\",\n  \"Multistage 3\",\n  \"Hill\",\n  \"Logistic quadratic\",\n  \"Logistic cubic\",\n  \"4 parameter log-logistic\"\n  #\"Logistic fractional polynomial\"\n  #\"Mixture multistage\"\n  #\"Box-Cox Weibull\"\n)\n\nobjectives = c(\n  \"D\",\n  \"A\"\n)\n\nalgorithms = c(\n  \"PSO\",\n  \"DE\"\n  #\"GWO\",\n  #\"HS\"\n)\n\nbmd_models = c(\n  \"Logistic\",\n  \"Weibull\",\n  \"Log-logistic\",\n  \"Hill\"\n)\n\n################################################################################\n# UI and server functions for app\n################################################################################\n\nui = fixedPage(\n  withMathJax(),\n  tabsetPanel(\n    selected = \"Find optimal designs\",\n    type = \"tabs\",\n    id = \"toptabpanel\",\n    tabPanel(\n      \"User manual\",\n\n      tags$h2(\"Overview of the app\", style = \"text-align:left;\"),\n      tags$p(\n        \"This app allows the user to find optimal experimental designs for\n          nonlinear models used in toxicology and for estimating the benchmark\n          dose. It also provides a tool for\n          comparing the efficiency of any two designs. This page explains how to use\n          the app and the optimal design theory used to generate and interpret the results.\"\n      ),\n      tags$p(\n        \"An optimal design for a dose-response experiment is a set of doses and\n        the proportion of subjects at each dose to efficiently fit a statistical model given a fixed sample size.\n        For example, we might want to find the best doses and subject allocation to estimate\n        a log-logistic model. The benefit of using an optimal design is the design\n        will maximize the information gained from the experiment. This can also\n        reduce the cost of the experiment since a well designed experiment with a\n        small number of subjects can be more effective than a bad experimental design\n        with a large sample size. For more information, see the optimal design reference\n        at the bottom of this tab.\"\n      ),\n      tags$p(\n        \"This app uses metaheuristic algorithms, which are a class of\n          optimization methods that have been widely used\n          to solve difficult problems. They are inspired by natural phenomena and simulate the\n          behavior of a group of entities, such as animals, insects, or particles,\n          in search of an optimal solution. Two examples of metaheuristic algorithms\n          are Particle Swarm Optimization (PSO) and Differential Evolution (DE).\n          They are especially useful in optimal design of experiments because they can easily be applied to a wide variety\n          of design problems.\"\n      ),\n      tags$h3(\"Design tab\", style = \"text-align:left;\"),\n      tags$p(\n        \"The design tab allows the user to use metaheuristic algorithms to find\n          the optimal design for a selected nonlinear model. The sidebar allows\n          the user to set several algorithm options. The algorithm selector chooses\n          metaheuristic to use to find the design and the iterations and swarm size\n          options tell the algorithm how long to run and the diversity of the search.\n          Increasing both the number of iterations and the swarm size will make it\n          more likely that the optimal design will be found but increases the run\n          time. The dose limit option controls the highest dose allowed.\n          The limit should be chosen based on background knowledge of the\n          experiment. A lower dose limit will limit the search space and make the\n          optimal design easier to find. The design points option controls how\n          many doses will be allowed in the optimal design. If too few doses are\n          specified, then the optimal design might be impossible to find. A general\n          rule of thumb is that the number of doses in the optimal design should\n          be equal to the number of parameters in the model.\"\n      ),\n      tags$p(\n        \"The main pane allows the user to select the model, parameter values,\n          and the design objective. Theta values should be entered separated by\n          commas, keeping in mind realistic bounds for the parameters.\n          Pressing the find design button will run the selected algorithm\n          options on the design problem, display the final design, and display a\n          graphical check of optimality.\n          If plotted function is less than 0 with equality at the doses in the design,\n          then the optimal design has been found. If the design is not optimal,\n          try re-running with more iterations and a larger swarm size. A different\n          algorithm might also help to find the optimal design. If the plot displays\n          a message about a singular information matrix, then there is likely a\n          problem with how the design problem is specified. The most common issue\n          is that the number of doses is too few. Another common issue is that\n          the dose range may be too small for the model in question.\"\n      ),\n      tags$p(\n        \"Some example theta values are shown for each model. These parameter values\n        were obtained by fitting the models to data from Table 3 from Haber et. al. (2018).\n        Models were fit using R and the EPA's Benchmark Dose Software.\"\n      ),\n      tags$h3(\"Compare tab\", style = \"text-align:left;\"),\n      tags$p(\n        \"The compare tab allows the user to compare two designs to see which\n          is more efficient. This is useful when comparing\n          a naive or more practical design against the optimal design.\n          Design 1 is compared relative to design design 2.\n          If design 1 is less efficient, then the efficiency will be less than 1.\n          If design 1 is more efficient, then the efficiency will be greater than 1.\n          Parameter values, dose levels, and weights should be entered as comma\n          separated values.\"\n      ),\n      tags$h3(\"BMD designs tab\", style = \"text-align:left;\"),\n      tags$p(\"This tab allows user to find designs for estimating the benchmark\n             dose (BMD). The options here are similar to the other design tab, but\n             there are a few features unique to the BMD designs. The BMD is defined\n             as the dose associated with a\n             pre-specified increase in the probability of toxicity compared to the\n             zero dose. There are two\n             ways to define this increase in risk. Added risk is defined as\n             $$\n             r_{add} = P(d) - P(0)\n             $$\n             and extra risk is defined as\n             $$\n             r_{extra} = \\\\frac{P(d) - P(0)}{1 - P(0)}\n             $$\n             The user can choose which risk definition to use by using the risk\n             type selector. It is also required to specify a risk increase between\n             0 and 1. Values of 0.05 and 0.10 are common choices.\"),\n      tags$p(\"The designs found in this tab are compound designs between c and D\n             optimality. The compound design is needed because the c-optimal\n             design for estimating the BMD is often inadequate for fitting the model.\n             For more details, see the section on compound designs in the optimal\n             design reference. The user must choose a value between 0 and 1\n             for the weighting parameter \\\\(\\\\lambda\\\\). A value of 0 gives the\n             D-optimal design while values close to 1 estimate the BMD more efficiently.\n             It is recommended to choose a \\\\(\\\\lambda\\\\) that gives at least 80%\n             D-efficiency.\"),\n\n      tags$h2(\"Optimal design reference\", style = \"text-align:left;\"),\n      tags$p(\n        \"\n          Suppose \\\\(Y\\\\) is an outcome variable of interest and \\\\(d\\\\) is the dosage or\n          concentration of the substance under investigation. We\n          additionally assume that \\\\(Y\\\\) is a binary variable that is equal to one\n          if toxicity has occurred and equal to 0 otherwise. We also assume the\n          that the dose \\\\(d\\\\) is in the range \\\\([0, D]\\\\) where \\\\(D\\\\) is highest\n          experimentally feasible dose. The goal of a dose response experiment\n          is to establish a mathematical relationship of the form\n$$\nP(Y = 1| d) = P(d) = f(d, \\\\theta) + \\\\epsilon\n$$\nwhere \\\\(f\\\\) is a possibly nonlinear function of the dose and parameters \\\\(\\\\theta\\\\).\nThe error term \\\\(\\\\epsilon\\\\) is assumed to have a normal distribution,\n\\\\(N(0, \\\\sigma^2)\\\\). Common forms of \\\\(f\\\\) include the exponential and inverse logit functions.\n\nThe goal of optimal design is to choose good values for the doses included in the\nexperiment and the number of subjects to assign to each dose. Let \\\\(d_i\\\\) denote the\nith dose in the design and let \\\\(n_i\\\\) be the number of subjects assigned to the ith\ndose for \\\\(i = 1, \\\\dots, k\\\\).  For theoretical convenience,\nwe assume a fixed sample size \\\\(N\\\\) and work with the proportions assigned to each\ndose instead of the raw \\\\(n_i\\\\). Define \\\\(w_i\\\\) as \\\\(w_i = n_i/N\\\\) such that \\\\(\\\\sum_i^k w_i = 1\\\\).\nUsing this weight-based notation, we can define a \\\\(k\\\\) dose design as a probability measure on \\\\([0, D]\\\\).\n$$\n\\\\xi = \\\\begin{pmatrix}\nd_1, & \\\\dots, & d_k\\\\\\\nw_1, & \\\\dots, & w_k\n\\\\end{pmatrix}\n$$\n\nThe design \\\\(\\\\xi\\\\) contains all of the variables that must be\nchosen optimally in order to maximize a design objective function.\nObjective functions in optimal design are based on the model information matrix,\n\\\\(M(\\\\xi, \\\\theta)\\\\). This information matrix can be thought of as the observed\ninformation matrix if the experiment is run using the design \\\\(\\\\xi\\\\). Note that \\\\(M(\\\\xi, \\\\theta)\\\\)\nalso depends on the parameter values of the model, meaning that a prior value for\nthe parameters is required. This value can come from previous data or theoretical\nmodels. The designs generated are referred to as \\\\(\\\\textit{locally optimal}\\\\) with\nrespect to \\\\(\\\\theta\\\\), meaning that the design is only optimal if \\\\(\\\\theta\\\\)\nis the true value. In light of this fact, sensitivity analyses should be performed\nto see how variation in \\\\(\\\\theta\\\\) might affect the design.\n\"\n      ),\n      tags$h3(\"Objective functions\", style = \"text-align:left;\"),\n      tags$p(\"Objective functions for optimal design are chosen to minimize the\n          variance of estimated quantities or, equivalently, to maximize the information\n          gain of the experiment. For example, a common design strategy is to minimize\n$$\n\\\\Psi_D(M) = -\\\\log |M|.\n$$\nMinimizing \\\\(\\\\Psi_D\\\\) is equivalent to minimizing the size of the confidence\nregion of the parameter estimates. A design that minimizes \\\\(\\\\Psi_D\\\\) is called\nD-optimal. Another approach is to minimize the objective function\n$$\n\\\\Psi_A(M) = \\\\operatorname{tr} M^{-1}.\n$$\nwhich is equivalent to minimizing the sum of the variances of the parameter estimates.\nAnother useful objective function is\n$$\n\\\\Psi_c(M) = c'M^{-1}c\n$$\nwhich minimizes the variance of some linear combination\nof the parameters. The \\\\(\\\\Psi_c\\\\) objective is useful is because it can be\napplied to construct a wide variety of domain specific objectives.\"\n             ),\n      tags$h3(\"Design efficiency\", style = \"text-align:left;\"),\n      tags$p(\"In order to make comparisons between designs, it is useful to consider\n efficiency relative to the optimal design. For example, we may wish to see how a\n naive design compares to the optimal design. In the case of D-optimality,\n let \\\\(\\\\xi_D\\\\) be the D-optimal design. The D-efficiency of a design \\\\(\\\\xi\\\\) is defined as\n $$\n \\\\operatorname{eff}_D(\\\\xi) = \\\\left(\\\\frac{|\\\\Psi_D(\\\\xi)|}{|\\\\Psi_D(\\\\xi_D)|}\\\\right)^{1/p}\n $$\n where \\\\(p\\\\) is the number of parameters in the model. Similar efficiency functions\n exist for the other optimality criteria. The design efficiency that takes a value\n             between 0 and 1, with values close to 1 signifying the design is close\n             to optimal.\"),\n      tags$h3(\"Equivalence theorem\", style = \"text-align:left;\"),\n      tags$p(\"A final useful tool for optimal design is the equivalence theorem of Kiefer (1960).\n This theorem says that if a design \\\\(\\\\xi\\\\) is optimal, then the directional\n derivative of the design criterion evaluated at \\\\(\\\\xi\\\\) must satisfy an inequality\n for all dose values in the design space with equality attained when the dose is\n in the design. This provides an easy graphical test to check if the design is\n optimal. An optimal design will produce a plot where the plotted function\n             curve stays below the y=0 line except at the doses in the design.\"),\n      tags$h3(\"Compound designs\", style = \"text-align:left;\"),\n      tags$p(\"A major issue with c-optimal designs is that they often result in\n             designs that are unable to fit the dose-response model. For example,\n             the c-optimal design for estimating the BMD is usually a single dose\n             design. A compound design criterion addresses this issue by using a\n             weighted combination of c and D-optimality. The compound criterion\n             is\n             $$\n             \\\\Psi_{CD}(M) = (1-\\\\lambda)\\\\log\\\\left[ \\\\text{eff}_D (M)\\\\right] + \\\\lambda \\\\log \\\\left[\\\\text{eff}_c (M)\\\\right]\n             $$\n             The weighting parameter \\\\(\\\\lambda\\\\) ranges between 0 and 1 and\n             can be used to set how much the design deviates from the D-optimal\n             design. The designs obtained using this criterion are very similar to\n             the D-optimal design with the same number of doses, but the designs are\n             usually no longer equally weighted. It is recommended to choose\n             \\\\( \\\\lambda\\\\) such that the design obtains a pre-specified level\n             of D-efficiency.\n             \")\n\n    ),\n    tabPanel(\n      \"Find optimal designs\",\n\n      tabsetPanel(\n        selected = \"Design\",\n        type = \"pills\",\n        id = \"designtabpanel\",\n        tabPanel(\"Design\",\n                 # sidebar layout for algorithm options\n                 sidebarLayout(\n                   sidebarPanel(\n                     tags$h3(\"Algorithm options\"),\n                     selectInput(\"algorithm\",\n                                 \"Algorithm\",\n                                 algorithms),\n                     numericInput(\"iter\",\n                                  \"Iterations\",\n                                  200,\n                                  1,\n                                  Inf,\n                                  10),\n                     numericInput(\"swarm\",\n                                  \"Swarm size\",\n                                  30,\n                                  10,\n                                  Inf,\n                                  10),\n                     numericInput(\"bound\",\n                                  \"Dose limit\",\n                                  30,\n                                  0.1,\n                                  Inf,\n                                  1),\n                     numericInput(\"pts\",\n                                  \"Max design points\",\n                                  3,\n                                  1,\n                                  10,\n                                  1),\n                     numericInput(\"seed\",\n                                  \"Seed\",\n                                  155,\n                                  1,\n                                  Inf,\n                                  1),\n                     numericInput(\n                       \"N\",\n                       \"N\",\n                       min = 1,\n                       max = 1000,\n                       value = 50\n                     )\n\n                   ),\n                   mainPanel(\n                     \"This tab is for finding A and D optimal designs for\n                     various dose response models. Prior values for the model\n                     parameters (theta) must be supplied. Theta values can be obtained\n                     from dedicated model fitting software or\n                     from published results. Check that the theta values have been\n                     entered correctly by plotting the response. Once the theta values have been entered,\n                     the design can be found by using the find design button. Note\n                     that these designs are locally optimal with respect to theta\n                     and will not be optimal if theta is misspecified. For\n                     more information on how to use the other options and tips, refer to\n                     the design tab section in the user manual tab.\",\n                     fluidRow(\n                       column(\n                         6,\n                         selectInput(\"model_selector\", \"Model\", models)\n                       ),\n                       column(\n                         6,\n                         textInput(\"theta_input\", \"Theta ( enter values separated by , )\"),\n                         selectInput(\"objective\", \"Objective\", objectives)\n                       )\n                     ),\n                     uiOutput(\"model_formula_display\"),\n                     uiOutput(\"example_theta\"),\n                     actionButton(\"find\", \"Find design\"),\n                     actionButton(\"plot_response\", \"Plot response\"),\n                     checkboxInput(\"log_dose_check\", \"Plot mean response on log dose scale\"),\n                     plotOutput(\"sens_plot\"),\n                     waiter::use_waiter(),\n                     verbatimTextOutput(\"design_out\"),\n                     actionButton(\"copy_design\", \"Copy design to compare tab\")\n                   )\n                 )),\n        tabPanel(\n          \"Compare\",\n          \"Compare the efficiency of design 1 relative to the\n          design 2. The efficiency is a number between 0 and 1 where\n          a value close to 1 means that design 1 is nearly as good as design 2.\n          If the efficiency is greater than 1, it implies that design 1 is better\n          than design design 2\",\n          \"The doses and weights may be obtained using the\n          other tabs and entered as comma separated values. Design 2 may\n          also be filled by using the copy button in the design tabs. For more\n          information, refer to the compare tab section in the user manual tab.\",\n          selectInput(\"model_selector_compare\", \"Model\", models),\n          textInput(\"theta_input_compare\", \"Theta ( enter values separated by , )\"),\n          selectInput(\"objective_compare\", \"Objective\", objectives),\n          fluidRow(\n            column(\n              6,\n              textInput(\"\\\\xi1_doses\", \"Design 1 doses\"),\n              textInput(\"\\\\xi1_weights\", \"Design 1 weights\")\n            ),\n            column(\n              6,\n              textInput(\"\\\\xi2_doses\", \"Design 2 doses\"),\n              textInput(\"\\\\xi2_weights\", \"Design 2 weights\")\n            ),\n            actionButton(\"compute_eff\", \"Compute efficiency\"),\n            #textOutput(\"eff_out\"),\n            verbatimTextOutput(\"eff_out\")\n          )\n        ),\n        tabPanel(\"BMD Designs\",\n                 # sidebar layout for algorithm options\n                 sidebarLayout(\n                   sidebarPanel(\n                     tags$h3(\"Algorithm options\"),\n                     selectInput(\"algorithm_bmd\",\n                                 \"Algorithm\",\n                                 algorithms),\n                     numericInput(\"iter_bmd\",\n                                  \"Iterations\",\n                                  200,\n                                  1,\n                                  Inf,\n                                  10),\n                     numericInput(\"swarm_bmd\",\n                                  \"Swarm size\",\n                                  30,\n                                  10,\n                                  Inf,\n                                  10),\n                     numericInput(\"bound_bmd\",\n                                  \"Dose limit\",\n                                  30,\n                                  0.1,\n                                  Inf,\n                                  1),\n                     numericInput(\"pts_bmd\",\n                                  \"Max design points\",\n                                  3,\n                                  1,\n                                  10,\n                                  1),\n                     numericInput(\"seed_bmd\",\n                                  \"Seed\",\n                                  155,\n                                  1,\n                                  Inf,\n                                  1),\n                     numericInput(\n                       \"N_bmd\",\n                       \"N\",\n                       min = 1,\n                       max = 1000,\n                       value = 50\n                     )\n\n                   ),\n                   mainPanel(\n                     \"This tab is for finding designs for estimating\n                     the benchmark dose (BMD) while efficiently estimating\n                     the model parameters. This tab works similarly to the other design\n                     tab, but includes several additional inputs. The risk type\n                     and a pre-specified level of risk for the BMD must both be set.\n                     These are described in more detail in the BMD designs tab\n                     section of the user manual. The user must also choose a lambda\n                     value to control the trade-off between estimating the BMD\n                     and the model parameters. The value of lambda ranges between 0\n                     and 1 with values close to 1 placing a higher priority on estimating\n                     the BMD. A good starting value for lambda is 0.5. More information\n                     and tips can be found in the user manual.\",\n                     fluidRow(\n                       column(\n                         6,\n                         selectInput(\"model_selector_bmd\", \"Model\", bmd_models),\n                         selectInput(\"risk_type_selector\", \"Risk type\", c(\"Added\", \"Extra\")),\n                         numericInput(\"risk\", \"Risk increase\",\n                                      value = 0.1, min = .01, max = .99, step = 0.01)\n                       ),\n                       column(\n                         6,\n                         textInput(\"theta_input_bmd\", \"Theta ( enter values separated by , )\"),\n                         numericInput(\"lambda_input\", \"\\\\(\\\\lambda\\\\) (weight parameter for c vs. D optimality)\",\n                                      value = 0.5, min = 0, max = 1, step = 0.1)\n                       )\n                     ),\n                     uiOutput(\"model_formula_display_bmd\"),\n                     uiOutput(\"example_theta_bmd\"),\n                     actionButton(\"find_bmd\", \"Find design\"),\n                     actionButton(\"plot_response_bmd\", \"Plot Response\"),\n                     checkboxInput(\"log_dose_check_bmd\", \"Plot mean response on log dose scale\"),\n                     checkboxInput('compute_Deff', 'Compute D-efficiency'),\n                     plotOutput(\"sens_plot_bmd\"),\n                     waiter::use_waiter(),\n                     verbatimTextOutput(\"design_out_bmd\"),\n                     actionButton(\"copy_design_bmd\", \"Copy design to compare tab\")\n                   )\n                 ))\n      )\n    )\n  )\n)\n\nserver = function(input, output, session) {\n\n  # reactive data structure\n  values <- reactiveValues()\n  values$DT <- data.frame(x = numeric(),\n                          y = numeric(),\n                          yhat = numeric()\n                          #color = factor(),\n                          #shape = factor()\n  )\n  values$eff_crit = c(\"NA\", \"?\")\n\n  # set up reactive data structure\n  # initialize with empty arrays and plots\n  values$OD <- list(\n    design = numeric(),\n    x = numeric(),\n    w = numeric(),\n    sens_plot = ggplot2::ggplot(),\n    msg = character()\n  )\n\n  # display model formula\n  output$model_formula_display = renderUI({\n    p(withMathJax(model_display(input$model_selector)))\n  })\n\n  # display of example local parameters\n  output$example_theta = renderUI({\n    p(withMathJax(display_example_param(input$model_selector)))\n  })\n\n\n  # sensitivity plot\n  output$sens_plot = renderPlot({\n\n    # load plot from reactive data\n    ggp = values$OD$sens_plot\n\n    # display plot\n    ggp\n  })\n\n  # action for Find button\n  observeEvent(\n    input$find,\n    {\n      # set up loading indicator\n      waiter <- waiter::Waiter$new(\n        id = \"sens_plot\",\n        html = waiter::spin_terminal(),\n        color = \"grey\"\n      )$show()\n      waiter$show()\n      on.exit(waiter$hide())\n\n      # grab and process theta from raw input\n      theta = process_theta(input$theta_input)\n\n      # check model bounds\n      model = input$model_selector\n      if (check_bounds(model, theta)) {\n        # select gradient function\n        grad_fun = grad_selector(model)\n\n        # find optimal design\n        out = find_design_single(\n          grad_fun,\n          input$objective,\n          theta,\n          input$bound,\n          input$pts,\n          input$algorithm,\n          input$swarm,\n          input$iter,\n          input$seed\n        )\n\n        # update reactive data with new design data\n        values$OD$msg = \"\"\n        values$OD$design = out$result$result\n        values$OD$sens_plot = out$plot\n        #values$OD$response_plot = response_plot\n        values$OD$val = out$result$optimumValue\n      }\n      else {\n        # show error message in plot\n        p = ggplot2::ggplot(mapping = ggplot2::aes()) +\n          ggplot2::theme_bw() +\n          ggplot2::annotate(\"text\", x = 5, y = 0.5,\n                            label = \"Theta values out of bound\", size = 5)\n        values$OD$sens_plot = p\n      }\n    }\n  )\n\n  # plotting dose response function\n  observeEvent(\n    input$plot_response,\n    {\n      model = input$model_selector\n      theta = process_theta(input$theta_input)\n      values$OD$sens_plot = plot_response(model, theta,\n                                          input$bound, input$log_dose_check)\n    }\n  )\n\n  # design output\n  output$design_out = renderPrint({\n\n    raw = values$OD$design\n    obj_val = values$OD$val[[1]]\n\n\n    # case if algorithm hasn't run\n    if (length(raw) == 0) {\n      cat(\"No design\")\n    }\n    else {\n      cat(\"Objective value:\", obj_val, \"\\n\")\n\n      # label and reorder\n      l = length(raw)\n      x = raw[1:(l/2)]\n      w = raw[(l/2 + 1):l]\n      cat(\"Doses:\\n\", signif(x[order(x)], 3), \"\\n\", sep = \" \")\n      cat(\"Weights:\\n\", round(w[order(x)], 3), \"\\n\", sep = \" \")\n\n      # save ordered doses and weights\n      values$OD$x = x[order(x)]\n      values$OD$w = w[order(x)]\n\n      # give example for a finite sample size\n      #n = 50\n      n = input$N\n      cat('Suggested allocations for N = ', n, \":\\n\", sep = '')\n      #cat(round(w[order(x)] * n), sep = ' ')\n      # last sample size N-1 to make allocations sum to N\n      ns = round(w[order(x)] * n)[-length(w)]\n      cat(c(ns, n - sum(ns)), sep = ' ')\n\n\n    }\n  })\n\n  observeEvent(\n    input$copy_design,\n    {\n      updateTextInput(session, \"\\\\xi2_doses\", value = toString(signif(values$OD$x, 3)))\n      updateTextInput(session, \"\\\\xi2_weights\", value = toString(round(values$OD$w, 3)))\n    }\n  )\n  ##############################################################################\n  # compare designs tab\n  ##############################################################################\n\n  # run when compare designs button\n  observeEvent(\n    input$compute_eff,\n    {\n\n      d1 = process_theta(input$`\\\\xi1_doses`)\n      d2 = process_theta(input$`\\\\xi2_doses`)\n      w1 = process_theta(input$`\\\\xi1_weights`)\n      w2 = process_theta(input$`\\\\xi2_weights`)\n      theta = process_theta(input$theta_input_compare)\n      eff = compute_eff(\n        input$model_selector_compare,\n        theta,\n        input$objective_compare,\n        d1,\n        d2,\n        w1,\n        w2\n      )\n\n      # save eff to reactive data\n      values$eff_crit = c(as.character(eff), input$objective_compare)\n\n    }\n  )\n\n  # display design efficiency\n  output$eff_out = renderPrint({\n    # sprintf(\"The %s-efficiency of design 1 relative to design 2 is %s\",\n    #         values$eff_crit[2], values$eff_crit[1])\n    cat(\"Criterion: \", values$eff_crit[2],\n        \"\\nEfficiency: \", values$eff_crit[1], \"\\n\")\n  })\n\n  ##############################################################################\n  # BMD design tab\n  ##############################################################################\n  # set up reactive data structure\n  # initialize with empty arrays and plots\n  values$OD2 <- list(\n    design = numeric(),\n    x = numeric(),\n    w = numeric(),\n    sens_plot = ggplot2::ggplot(),\n    msg = character(),\n    Deff = NA\n  )\n\n  # display model formula\n  output$model_formula_display_bmd = renderUI({\n    p(withMathJax(model_display(input$model_selector_bmd)))\n  })\n\n  # example theta values\n  output$example_theta_bmd = renderUI({\n    p(withMathJax(display_example_param(input$model_selector_bmd)))\n  })\n\n  # sensitivity plot\n  output$sens_plot_bmd = renderPlot({\n\n    # load plot from reactive data\n    ggp = values$OD2$sens_plot\n\n    # display plot\n    ggp\n  })\n\n  # action for Find button\n  observeEvent(\n    input$find_bmd,\n    {\n      # set up loading indicator\n      waiter <- waiter::Waiter$new(\n        id = \"sens_plot_bmd\",\n        html = waiter::spin_terminal(),\n        color = \"grey\"\n      )$show()\n      waiter$show()\n      on.exit(waiter$hide())\n\n      # grab and process theta from raw input\n      theta = process_theta(input$theta_input_bmd)\n\n      # check theta values\n      model = input$model_selector_bmd\n      if (check_bounds(model, theta)) {\n        # select gradient function\n        if (model == \"Logistic\")\n          grad_fun = grad.logistic\n        else if (model == \"Weibull\")\n          grad_fun = grad.weibull\n        else if (model == \"Log-logistic\")\n          grad_fun = grad.loglogistic\n\n\n        # find optimal design\n        out = find_bmd_design(\n          model,\n          input$lambda_input,\n          input$risk,\n          input$risk_type_selector,\n          theta,\n          input$bound_bmd,\n          input$pts_bmd,\n          input$algorithm_bmd,\n          input$swarm_bmd,\n          input$iter_bmd,\n          input$seed_bmd\n        )\n\n\n        # update reactive data with new design data\n        values$OD2$msg = \"\"\n        values$OD2$design = out$result$result\n        values$OD2$sens_plot = out$plot\n        #values$OD$response_plot = response_plot\n        values$OD2$val = out$result$optimumValue\n\n        # compute D-efficiency if box if checked\n        if (input$compute_Deff) {\n          #browser()\n          # find D-optimal design\n          # current algorithm choices should be good enough to find the design\n          # grab and process theta from raw input\n          theta = process_theta(input$theta_input_bmd)\n\n          # check model bounds\n          model = input$model_selector_bmd\n          if (check_bounds(model, theta)) {\n            # select gradient function\n            grad_fun = grad_selector(model)\n\n            # find optimal design\n            out = find_design_single(\n              grad_fun,\n              'D',\n              theta,\n              input$bound_bmd,\n              input$pts_bmd,\n              input$algorithm_bmd,\n              input$swarm_bmd,\n              input$iter_bmd,\n              input$seed_bmd\n            )$result$result\n\n            # process\n            l = length(values$OD2$design)\n            x = values$OD2$design[1:(l/2)]\n            w = values$OD2$design[(l/2 + 1):l]\n\n            l_d = length(out)\n            x_d = out[1:(l_d/2)]\n            w_d = out[(l_d/2 + 1):l_d]\n\n            # compute D efficiency and save to reactive\n            values$OD2$Deff = compute_eff(\n              model,\n              theta,\n              'D',\n              d1 = x,\n              d2 = x_d,\n              w1 = w,\n              w2 = w_d\n            )\n          }\n        }\n      }\n      else {\n        # show error message in plot\n        p = ggplot2::ggplot(mapping = ggplot2::aes()) +\n          ggplot2::theme_bw() +\n          ggplot2::annotate(\"text\", x = 5, y = 0.5,\n                            label = \"Theta values out of bound\", size = 5)\n        values$OD2$sens_plot = p\n      }\n\n\n    }\n  )\n\n  # plotting dose response function\n  observeEvent(\n    input$plot_response_bmd,\n    {\n      model = input$model_selector_bmd\n      theta = process_theta(input$theta_input_bmd)\n      values$OD2$sens_plot = plot_response(model, theta,\n                                          input$bound_bmd, input$log_dose_check_bmd)\n    }\n  )\n\n  # design output\n  output$design_out_bmd = renderPrint({\n\n    raw = values$OD2$design\n    obj_val = values$OD2$val[[1]]\n\n\n    # case if algorithm hasn't run\n    if (length(raw) == 0) {\n      cat(\"No design\")\n    }\n    else {\n      cat(\"Objective value:\", obj_val, \"\\n\")\n\n      # label and reorder\n      l = length(raw)\n      x = raw[1:(l/2)]\n      w = raw[(l/2 + 1):l]\n      cat(\"Doses:\\n\", signif(x[order(x)], 3), \"\\n\", sep = \" \")\n      cat(\"Weights:\\n\", round(w[order(x)], 3), \"\\n\", sep = \" \")\n\n      # save ordered doses and weights\n      values$OD2$x = x[order(x)]\n      values$OD2$w = w[order(x)]\n\n      # give example for a finite sample size\n      n = input$N_bmd\n      cat('Suggested allocations for N = ', n, \":\\n\", sep = '')\n      #cat(floor(w[order(x)] * n), sep = ' ')\n      # last sample size N-1 to make allocations sum to N\n      ns = round(w[order(x)] * n)[-length(w)]\n      cat(c(ns, n - sum(ns)), sep = ' ')\n      cat(\"\\nD-efficiency:\", round(values$OD2$Deff, 2))\n    }\n  })\n\n  observeEvent(\n    input$copy_design_bmd,\n    {\n      updateTextInput(session, \"\\\\xi2_doses\", value = toString(signif(values$OD2$x, 3)))\n      updateTextInput(session, \"\\\\xi2_weights\", value = toString(round(values$OD2$w, 3)))\n    }\n  )\n\n}\n\n################################################################################\n# Gradient functions, objective functions, and derivatives\n################################################################################\ngrad.logistic = function(x, theta) {\n\n  eta = theta[1] + theta[2] * x\n  sigma = exp(eta)/(1 + exp(eta))^2\n  grad = sigma * c(1, x)\n  return(grad)\n}\n\ngrad.logistic.quad = function(x, theta) {\n\n  eta = theta[1] + theta[2] * x + theta[3] * x^2\n  sigma = exp(eta)/(1 + exp(eta))^2\n  grad = sigma * c(1, x, x^2)\n  return(grad)\n}\n\ngrad.logistic.cubic = function(x, theta) {\n  eta = theta[1] + theta[2] * x + theta[3] * x^2 + theta[4] * x^3\n  sigma = exp(eta)/(1 + exp(eta))^2\n  grad = sigma * c(1, x, x^2, x^3)\n  return(grad)\n}\n\n# 2nd degree fractional polynomial predictor\ngrad.logistic.fp = function(x, theta) {\n\n  # theta4 and theta5 are power paramters in this model\n  powers = c(0, theta[4], theta[5])\n\n  # x1 is the 2nd term in the polynomial\n  x1 = H(2, x, powers)\n  x2 = H(3, x, powers)\n  eta = theta[1] + theta[2] * x1 + theta[3] * x2\n  sigma = exp(eta)/(1 + exp(eta))^2\n  grad = sigma * c(1, x1, x2)\n  return(grad)\n\n}\n\n# mixture of two multistage models\n# Razzaghi (2002) in Envirometrics\ngrad.mix2 = function(x, theta) {\n\n  # identify parameters\n  a = theta[1]\n  b = theta[2]\n  c = theta[3]\n  d = theta[4]\n  f = theta[5]\n  g = theta[6]\n\n  # gradient components\n  d1 = g*exp(-a-b*x-c*x^2) + (1-g)*exp(-a-d*x-f*x^2)\n  d2 = g*x*exp(-a-x*(b+c*x))\n  d3 = g * x^2 * exp(-a-x*(b+c*x))\n  d4 = (1 - g)*x*exp(-a-x*(d+f*x))\n  d5 = (1 - g) *x^2 * exp(-a-x*(d+f*x))\n  d6 = exp(-a-d*x-f*x^2) - exp(-a-b*x-c*x^2)\n  grad = c(d1, d2, d3, d4, d5, d6)\n  return(grad)\n}\n\n# Box-Cox Weibull model from Backhaus et al (2000)\n# P(x) = 1 - exp( -exp(theta1 + theta2 * (x^theta3 - 1)/theta3) )\ngrad.boxcoxweibull = function(x, theta) {\n\n  # identify parameters\n  a = theta[1]\n  b = theta[2]\n  c = theta[3]\n\n  # gradient components\n  d1 = exp(-exp(a + b*(x^c-1)/c) + a + b*(x^c-1)/c)\n  d2 = (x^c - 1)*exp(-exp(a + b*(x^c-1)/c) + a + b*(x^c-1)/c)/c\n  d3 = (b*x^c * log(x)/c - b*(x^c-1)/c^2) * exp(-exp(a + b*(x^c-1)/c) + a + b*(x^c-1)/c)\n  grad = c(d1, d2, d3)\n  return(grad)\n\n}\n\n# Weibull model\n# using version found in BMDS\n# P[dose] = g + (1 - g) * (1 - exp(-b * dose^a))\ngrad.weibull = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = exp(-b * x^a)\n  g2 = -b * (g - 1) * x^a * log(x) * exp(-b * x^a)\n  g3 = (g - 1) * x^a * (-exp(-b * x^a))\n  return(c(g1, g2, g3))\n}\n\n# log-logistic model\n# using version from BMDS\n# P[dose] = g + (1 - g)/(1 + exp(-a - b * Log(dose)))\ngrad.loglogistic = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = 1/(exp(a) * x^b + 1)\n  g2 = (1-g)*exp(-a-b*log(x))/(exp(-a-b*log(x)) + 1)^2\n  g3 = (1-g)*log(x)*exp(-a-b*log(x))/(exp(-a-b*log(x))+1)^2\n  return(c(g1, g2, g3))\n}\n\n# Hill model\n# P(d) = g + (v - v*g) / (1 + exp(-a-b*log(d)))\ngrad.hill = function(x, theta) {\n\n  g = theta[1]\n  v = theta[2]\n  a = theta[3]\n  b = theta[4]\n\n  g1 = 1 - exp(a) * v * x^b / (exp(a) * x^b + 1)\n  g2 = - exp(a) * (g-1) * x^b / (exp(a)*x^b + 1)\n  g3 = - exp(a) * (g-1) * v * x^b / (exp(a) * x^b + 1)^2\n  g4 = - exp(a)*(g-1)*v*x^b*log(x) / (exp(a) * x^b + 1)^2\n  return(c(g1, g2, g3, g4))\n\n}\n\n# multistage 1\n# P(d) = g + (1-g)*(1-exp(-a*d))\ngrad.multi1 = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n\n  g1 = exp(-a * x)\n  g2 = -(g-1)*x*exp(-a*x)\n  return(c(g1, g2))\n}\n\n# multistage 2\n# P(d) = g + (1-g)*(1-exp(-a*d - b*d^2))\ngrad.multi2 = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = exp(-a*x - b*x^2)\n  g2 = (1-g)*x*exp(-a*x - b*x^2)\n  g3 = (1-g)*x^2*exp(-a*x - b*x^2)\n  return(c(g1, g2, g3))\n}\n\n# multistage 3\n# P(d) = g + (1-g)*(1-exp(-a*d - b*d^2 - c*d^3))\ngrad.multi3 = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n  c = theta[4]\n\n  g1 = exp(-a*x - b*x^2 - c*x^3)\n  g2 = x*(1-g)*exp(-a*x - b*x^2 - c*x^3)\n  g3 = x^2*(1-g)*exp(-a*x - b*x^2 - c*x^3)\n  g4 = x^3*(1-g)*exp(-a*x - b*x^2 - c*x^3)\n  return(c(g1, g2, g3, g4))\n}\n\n# probit\n# P(d) = phi(a + bx)\ngrad.probit = function(x, theta) {\n\n  a = theta[1]\n  b = theta[2]\n\n  g1 = 1/sqrt(2*pi)*exp(-(a+b*x)^2/2)\n  g2 = 1/sqrt(2*pi)*exp(-(a+b*x)^2/2) * x\n  return(c(g1, g2))\n}\n\n# log probit\n# P(d) = g + (1-g) * phi(a + b*log(d))\ngrad.logprobit = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = 1 - pnorm(a + b * log(x))\n  g2 = (1-g) * 1/sqrt(2*pi)*exp(-(a+b*log(x))^2/2)\n  g3 = (1-g) * 1/sqrt(2*pi)*exp(-(a+b*log(x))^2/2) * log(x)\n  return(c(g1, g2, g3))\n}\n\n# 4 parameter logistic\n# P(x) = g + (c - g)/(1 + exp(-a - b * log(x)))\ngrad.loglogistic4 = function(x, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n  c = theta[4]\n\n  g1 = 1 / (exp(a) * x^b + 1)\n  g2 = (c - g) * exp(-a-b*log(x)) / (exp(-a-b*log(x)) + 1)^2\n  g3 = (c - g) * exp(-a-b*log(x)) * log(x) / (exp(-a-b*log(x)) + 1)^2\n  g4 = 1 / (exp(-a) * x^(-b) + 1)\n  return(c(g1, g2, g3, g4))\n}\n\n\n################################################################################\n# Objective functions\n################################################################################\n# D optimality\n# maximize logdetM\nobj.D = function(M, param) {\n  suppressWarnings(log(det(M)))\n}\n\n# A optimality\n# minimize trM^-1\nobj.A = function(M, param) {\n\n  # check if matrix is invertible\n  if (!checkMinv(M))\n    return(-Inf)\n  else\n    return(-sum(diag(solve(M))))\n}\n\n# BMD optimality\nobj.bmd = function(M, param) {\n\n  lambda = param[1]\n  c = param[-1]\n  if (!checkMinv(M))\n    return(-Inf)\n  else {\n    Minv = solve(M)\n    Dval = suppressWarnings(log(det(M)))\n    Cval = -suppressWarnings(log(t(c) %*% Minv %*% c)) # note the sign flip\n    p = length(c)\n    return(lambda * Cval + (1 - lambda)/p * Dval)\n  }\n}\n\n# derivatives of objective functions with respect to information matrix\n# matrix singularity is already checked here\n# M: information matrix\ndPsi.D = function(M, param) {\n  Minv = solve(M)\n  return(Minv)\n}\n\ndPsi.A = function(M, param) {\n  Minv = solve(M)\n  Minv2 = Minv %*% Minv\n  return(Minv2)\n}\n\n# compound D and c\n# see Atkinson book p389\ndPsi.CD = function(M, param) {\n\n  Minv = solve(M)\n  p = nrow(M)\n  lambda = param[1]\n  c = param[-1]\n  num = Minv %*% c %*% t(c) %*% Minv\n  denom = c(t(c) %*% Minv %*% c)\n\n  return((1 - lambda)/p * Minv + lambda/denom * num)\n}\n\n################################################################################\n# Main driver functions\n################################################################################\nfind_design_single = function(\n    grad_fun,\n    obj,\n    theta,\n    bound,\n    pts,\n    algorithm,\n    swarm,\n    iter,\n    seed\n) {\n\n  # design objective\n  if (obj == \"D\")\n    obj_fun = obj.D\n  else if (obj == \"A\")\n    obj_fun = obj.A\n  else\n    stop(\"Objective not supported\")\n\n  # objective function\n  param = c()\n  obj_fun_M = obj_fun_factory(grad_fun, obj_fun, theta, param)\n\n  # set up variable bounds\n  rangeVar = matrix(c(rep(c(0, bound), pts), rep(c(0,1), pts)), nrow = 2)\n\n  # algorithm options\n  control = list(numPopulation = swarm, maxIter = iter)\n\n  # find design\n  result = metaheuristicOpt::metaOpt(\n    obj_fun_M,\n    optimType = \"MAX\",\n    algorithm = algorithm,\n    numVar = 2 * pts,\n    rangeVar,\n    control,\n    seed = seed\n  )\n\n  # check optimality\n  vars = result$result\n  x = vars[1:pts]\n  w = vars[(pts+1):(2*pts)]\n\n  # collapse doses if weights are small\n  x = x[w > 1e-5]\n  w = w[w > 1e-5]\n  result$result = c(x, w)\n\n  M = M.nonlinear(x, w, theta, grad_fun)\n  problem = list(bound = bound, obj = obj, theta = theta)\n  p = plot_sens(x, w, problem, M, grad_fun)\n\n  return(list(result = result, plot = p))\n}\n\n# function for computing design efficiencies\ncompute_eff = function(\n    model,\n    theta,\n    objective,\n    d1,\n    d2,\n    w1,\n    w2\n) {\n\n  # normalize user submitted weights\n  w1 = w1/sum(w1)\n  w2 = w2/sum(w2)\n\n  # if any of the doses are 0, add a small value\n  d1[which(d1==0)] = 1e-3\n  d2[which(d2==0)] = 1e-3\n\n  # select gradient function\n  grad_fun = grad_selector(model)\n\n  if (objective == \"D\")\n    obj_fun = obj.D\n  else if (objective == \"A\")\n    obj_fun = obj.A\n\n  # define objective function\n  param = c()\n  obj_fun_M = obj_fun_factory(grad_fun, obj_fun, theta, param)\n\n  # compute and return efficiencies\n  if (objective == \"D\")\n    eff = (exp(obj_fun_M(c(d1, w1)))/exp(obj_fun_M(c(d2, w2))))^(1/length(theta))\n  else if (objective == \"A\")\n    eff = obj_fun_M(c(d2, w2))/obj_fun_M(c(d1, w1))\n\n  return(round(eff, 3))\n}\n\n# function for finding BMD designs\n# basically a compound optimal design\n# lambda is the weight parameter\nfind_bmd_design = function(\n    model,\n    lambda,\n    risk,\n    risk_type,\n    theta,\n    bound,\n    pts,\n    algorithm,\n    swarm,\n    iter,\n    seed\n) {\n  #browser()\n  # select gradient functions\n  if (model == \"Logistic\") {\n    grad_fun = grad.logistic\n\n    if (risk_type == \"Added\") {\n      bmd_grad = bmdgrad.logistic.add\n    }\n    else if (risk_type == \"Extra\")\n      bmd_grad = bmdgrad.logistic.extra\n  }\n  else if (model == \"Weibull\") {\n    grad_fun = grad.weibull\n\n    if (risk_type == \"Added\") {\n      bmd_grad = bmdgrad.weibull.add\n    }\n    else if (risk_type == \"Extra\") {\n      bmd_grad = bmdgrad.weibull.extra\n    }\n  }\n  else if (model == \"Log-logistic\") {\n    grad_fun = grad.loglogistic\n\n    if (risk_type == \"Added\") {\n      bmd_grad = bmdgrad.loglogistic.add\n    }\n    else if (risk_type == \"Extra\") {\n      bmd_grad = bmdgrad.loglogistic.extra\n    }\n  }\n  else if (model == \"Hill\") {\n    grad_fun = grad.hill\n\n    if (risk_type == \"Added\") {\n      bmd_grad = bmdgrad.hill.add\n    }\n    else if (risk_type == \"Extra\") {\n      bmd_grad = bmdgrad.hill.extra\n    }\n  }\n\n\n  # objective function\n  c = bmd_grad(risk, theta) # compute BMD gradient components\n  param = c(lambda, c)\n  obj_fun = obj.bmd\n  obj_fun_M = obj_fun_factory(grad_fun, obj_fun, theta, param)\n\n  # set up variable bounds\n  rangeVar = matrix(c(rep(c(0, bound), pts), rep(c(0,1), pts)), nrow = 2)\n\n  # algorithm options\n  control = list(numPopulation = swarm, maxIter = iter)\n\n  # find design\n  result = metaheuristicOpt::metaOpt(\n    obj_fun_M,\n    optimType = \"MAX\",\n    algorithm = algorithm,\n    numVar = 2 * pts,\n    rangeVar,\n    control,\n    seed = seed\n  )\n\n  # check optimality\n  vars = result$result\n  x = vars[1:pts]\n  w = vars[(pts+1):(2*pts)]\n\n  # collapse doses if weights < 1e-5\n  x = x[w > 1e-5]\n  w = w[w > 1e-5]\n  result$result = c(x, w)\n\n  M = M.nonlinear(x, w, theta, grad_fun)\n  problem = list(bound = bound, obj = \"bmd\", theta = theta, param = param)\n  p = plot_sens(x, w, problem, M, grad_fun)\n\n  # compute D-efficiency of design\n  #D_eff = compute_eff(model, theta, \"bmd\", )\n  # probably need to make this an option\n\n  return(list(result = result, plot = p))\n\n}\n################################################################################\n# Core optimal design related functions\n################################################################################\n# function for constucting objective function for use with algorithms\n# M_fun: information matrix function\n# obj_fun: objective function of information matrix\n# theta: parameter values to pass through to M_fun\n# par: other parameters, such as c values for c objective\nobj_fun_factory = function(grad_fun, obj_fun, theta, param) {\n\n  # these are used in interface function\n  force(grad_fun)\n  force(theta)\n  force(param)\n\n  # interface called by optimization software\n  # return this function\n  function(vars, ...) {\n    # distinguish between points and weights\n    pts = length(vars)/2\n    x = vars[1:pts]\n    w = vars[(pts+1):(2*pts)]\n\n    # check weight constraint\n    s = sum(w, na.rm = T) # na.rm needed to fix if statement error\n    if (s > 1) # constraint implementation\n      return(-Inf)\n\n    M_fun = M.nonlinear # always using general nonlinear matrix\n    obj_value = obj_fun(M_fun(x, w, theta, grad_fun), param)\n\n    # deal with missing\n    if (is.na(obj_value))\n      return(-Inf)\n    else\n      return(obj_value)\n  }\n\n}\n\n\n# information matrix\n# x: array of design points\n# w: array of weights\n# theta: array of parameter values\n# most general case\n# grad_fun: gradient function to use\nM.nonlinear = function(x, w, theta, grad_fun) {\n\n  IM = 0\n  for (i in 1:length(x)) {\n    IM_i = w[i] * grad_fun(x[i], theta) %*% t(grad_fun(x[i],theta))\n    IM = IM + IM_i\n  }\n  IM\n}\n\n\n# plot sensitivity function for a given design\n# problem is same list from toxODmeta\n# x, w are design point and weight vectors\n# M: pre-computed information matrix\n# grad_fun: gradient function\nplot_sens = function(x, w, problem, M, grad_fun) {\n\n  # x values\n  step = problem$bound/1000\n  xvals = seq(0, problem$bound, step)\n\n  # select derivative function for sensitivity function\n  if (problem$obj == \"D\") {\n    dPsi = dPsi.D\n    param = NULL\n  }\n  else if (problem$obj == \"A\") {\n    dPsi = dPsi.A\n    param = NULL\n  }\n  else if (problem$obj == \"bmd\") {\n\n    dPsi = dPsi.CD\n    param = problem$param\n  }\n  else {\n    # expand this to handle solving design problems with no verification\n    #stop(\"No derivative specified for this objective.\")\n    # use y=2 to denote missing derivative function\n    yvals = rep(2, length(xvals))\n  }\n\n  # compute sensitivity function\n  # check first if matrix is invertible and then invert\n  if (!checkMinv(M)) {\n    # using y=1 to denote matrix singularity\n    yvals = rep(1, length(xvals))\n  }\n  else {\n    Minv = solve(M)\n    yvals = sapply(xvals, sens, grad_fun, dPsi, M, problem$theta, param)\n  }\n\n\n\n  # plot\n  # display message if missing matrix deriv or singular matrix\n  if (sum(yvals - 1, na.rm = T) == 0) {\n    p = ggplot2::ggplot(mapping = ggplot2::aes(y = yvals, x = xvals)) +\n      ggplot2::geom_line(color = \"blue\") +\n      ggplot2::geom_hline(yintercept = 0) +\n      ggplot2::theme_bw() +\n      ggplot2::labs(title = \"Equivalence Theorem Check\") +\n      ggplot2::xlab(\"x\") +\n      ggplot2::ylab(\"ch(x)\") +\n      ggplot2::annotate(\"text\", x = mean(xvals), y = 0.5,\n                        label = \"Singular information matrix, try increasing max design points.\", size = 5)\n  }\n  else if (sum(yvals - 2, na.rm = T) == 0) {\n    p = ggplot2::ggplot(mapping = ggplot2::aes(y = yvals, x = xvals)) +\n      ggplot2::geom_line(color = \"blue\") +\n      ggplot2::geom_hline(yintercept = 0) +\n      ggplot2::theme_bw() +\n      ggplot2::labs(title = \"Equivalence Theorem Check\") +\n      ggplot2::xlab(\"x\") +\n      ggplot2::ylab(\"ch(x)\") +\n      ggplot2::annotate(\"text\", x = mean(xvals), y = 0.5,\n                        label = \"No dPsi defined\", size = 5)\n  }\n  else {\n    p = ggplot2::ggplot(mapping = ggplot2::aes(y = yvals, x = xvals)) +\n      ggplot2::geom_line(color = \"blue\") +\n      ggplot2::geom_hline(yintercept = 0) +\n      #ggplot2::geom_point(aes(x = design_points, y = pts_ch), col = \"red\", size = 3) +\n      ggplot2::geom_vline(xintercept = x, color = \"red\", linetype = \"dashed\") +\n      ggplot2::theme_bw() +\n      ggplot2::labs(title = \"Optimality check\", subtitle = 'Is the blue line equal to 0 at the selected doses (red lines) and less than 0 everywhere else?') +\n      ggplot2::xlab(\"dose\") +\n      ggplot2::ylab(\"directional derivative\")\n  }\n\n\n  return(p)\n}\n\n# sensitivity function\n\n# general function\n# z: independent variable\n# grad: gradient function\n# dPsi: derivative of the objective function wrt M\n# M: information matrix\n# theta: model parameters\nsens = function(z, grad, dPsi, M, theta, param) {\n\n  dg = grad(z, theta)\n  dM = dPsi(M, param)\n  y = t(dg) %*% dM %*% dg - sum(diag(M %*% dM))\n  return(y)\n}\n\n################################################################################\n# Other utility functions\n################################################################################\n# function that displays latex formulas for models in app\nmodel_display = function(model) {\n\n  if (model == \"Hill\")\n    \"$$ P(d) = \\\\theta_1 + \\\\frac{(\\\\theta_2 - \\\\theta_2 \\\\theta_1)}{1 + \\\\exp(-\\\\theta_3 - \\\\theta_4\\\\log (d))} $$\"\n  # else if (model == \"Gamma\") # don't know how to do this => Elvis' paper reparameterizes\n  #   \"$$ P(d) = $$\"\n  else if (model == \"Logistic\")\n    \"$$ P(d) = \\\\frac{1}{1 + \\\\exp(-\\\\theta_1 - \\\\theta_2 d)} $$\"\n  else if (model == \"Logistic quadratic\")\n    \"$$P(d) = \\\\frac{1}{1 + \\\\exp(-\\\\theta_1 - \\\\theta_2 d - \\\\theta_3 d^2)}$$\"\n  else if (model == \"Logistic cubic\")\n    \"$$P(d) = \\\\frac{1}{1 + \\\\exp(-\\\\theta_1 - \\\\theta_2 d - \\\\theta_3 d^2 - \\\\theta_4 d^3)}$$\"\n  else if (model == \"Logistic fractional polynomial\") {\n    \"$$P(d) = \\\\frac{1}{1 + \\\\exp(-\\\\theta_1 - \\\\theta_2 d^{\\\\theta_4} - \\\\theta_3 d^{\\\\theta_5})}$$\n    \\n Note: the exponent parameters are considered known and the design is not\n    optimal for estimating these parameters. The optimal design will most likely\n    have 3 doses.\"\n\n  }\n  else if (model == \"Log-logistic\")\n    \"$$ P(d) = \\\\theta_1 +  \\\\frac{1-\\\\theta_1}{1 + \\\\exp(-\\\\theta_2- \\\\theta_3 \\\\log d)}$$\"\n  else if (model == \"Log-probit\")\n    \"$$ P(d) = \\\\theta_1 + (1 - \\\\theta_1) \\\\Phi(\\\\theta_2 + \\\\theta_3 \\\\log(d))$$\"\n  else if (model == \"Probit\")\n    \"$$P(d)=\\\\Phi(\\\\theta_1 + \\\\theta_2 d)$$\"\n  else if (model == \"Quantal linear\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1)(1-\\\\exp(-\\\\theta_2 d))$$\"\n  else if (model == \"Weibull\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1)(1-\\\\exp(-\\\\theta_3 d^{\\\\theta_2}))$$\"\n  else if (model == \"Mixture multistage\")\n    \"$$P(d) = \\\\theta_6 \\\\left[1 - \\\\exp(-\\\\theta_1-\\\\theta_2 d - \\\\theta_3 d^2) \\\\right] + (1-\\\\theta_6)\\\\left[1 - \\\\exp(-\\\\theta_1 - \\\\theta_4 d - \\\\theta_5 d^2) \\\\right]$$\"\n  else if (model == \"Box-Cox Weibull\")\n    \"$$P(d)=1-\\\\exp \\\\left[ -\\\\exp \\\\left(\\\\theta_1 + \\\\theta_2 \\\\frac{d^{\\\\theta_3}-1}{\\\\theta_3}\\\\right)\\\\right]$$\"\n  else if (model == \"Hill\")\n    \"$$P(d) = \\\\theta_1 + \\\\frac{\\\\theta_2 - \\\\theta_2\\\\theta_1}{1+\\\\exp(-\\\\theta_3 - \\\\theta_4 d)}$$\"\n  else if (model == \"Multistage 1\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1)(1 - \\\\exp(-\\\\theta_2 d))$$\"\n  else if (model == \"Multistage 2\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1)(1 - \\\\exp(-\\\\theta_2 d - \\\\theta_3 d^2))$$\"\n  else if (model == \"Multistage 3\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1)(1 - \\\\exp(-\\\\theta_2 d - \\\\theta_3 d^2 - \\\\theta_4 d^3))$$\"\n  else if (model == \"Probit\")\n    \"$$P(d) = \\\\phi(\\\\theta_1 + \\\\theta_2 d)$$\"\n  else if (model == \"Log-probit\")\n    \"$$P(d) = \\\\theta_1 + (1-\\\\theta_1) \\\\phi(\\\\theta_2 + \\\\theta_3 * \\\\log(d))$$\"\n  else if (model == \"4 parameter log-logistic\")\n    \"$$P(d) = \\\\theta_1 + \\\\frac{(\\\\theta_4 - \\\\theta_1)}{1 + \\\\exp(-\\\\theta_2 - \\\\theta_3 \\\\log(d))}$$\"\n  else\n    \"Model not supported\"\n\n}\n\n# displays example local theta values\n# model: string from model selector\n# returns: string to be displayed by Shiny ui element\ndisplay_example_param = function(model) {\n\n  if (model == \"Hill\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.02201, 0.9034, -2.132, 1)\"\n  else if (model == \"Logistic\")\n    \"EX: \\\\(\\\\theta\\\\) = (-1.710, 0.09703)\"\n  else if (model == \"Logistic quadratic\")\n    \"EX: \\\\(\\\\theta\\\\) = (-2.52, 0.26, -0.006)\"\n  else if (model == \"Logistic cubic\")\n    \"EX: \\\\(\\\\theta\\\\) = (-3.91, 1.56, -0.18, 0.004)\"\n  else if (model == \"Logistic fractional polynomial\") {\n    \"EX: \\\\(\\\\theta\\\\) = ()\"\n  }\n  else if (model == \"Log-logistic\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.02461, -2.390, 1)\"\n  else if (model == \"Log-probit\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.02051, -1.237, 0.5173)\"\n  else if (model == \"Probit\")\n    \"EX: \\\\(\\\\theta\\\\) = (-1.051, 0.05948)\"\n  else if (model == \"Quantal linear\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.05307, 0.04929)\"\n  else if (model == \"Weibull\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.05307, .99, 0.04929)\"\n  else if (model == \"Multistage 1\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.05307, 0.04929)\"\n  else if (model == \"Multistage 2\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.05307, 0.04929, 0)\"\n  else if (model == \"Multistage 3\")\n    \"EX: \\\\(\\\\theta\\\\) = (0.05307, 0.04929, 0, 0)\"\n  else if (model == '4 parameter log-logistic')\n    'EX: \\\\(\\\\theta\\\\) = (1.01, -2.93, 0.54, 140.09)'\n  else\n    \"EX: \\\\(\\\\theta\\\\) = \"\n\n\n}\n\n# convert raw text input to a vector of parameter values\n# pulling this out into its own function because input checking could be complex\n# useful in multiple places where there is text input\nprocess_theta = function(text) {\n  as.numeric(strsplit(text, \",\")[[1]])\n}\n\n# function for checking model parameter bounds\n# inputs: model type and parameters\n# returns true if parameters are within bounds for model\ncheck_bounds = function(model, theta) {\n\n  # being very generous on beta coefficient ranges\n  if (model == \"Logistic\") {\n    if (theta[1] < -20 | theta[1] > 20)\n      return(FALSE)\n    if (theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Logistic quadratic\") {\n    if (theta[1] < -20 | theta[1] > 20)\n      return(FALSE)\n    if (theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if (theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Logistic cubic\") {\n    if (theta[1] < -20 | theta[1] > 20)\n      return(FALSE)\n    if (theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if (theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n    if (theta[4] < -100 | theta[4] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Logistic fractional polynomial\") {\n    if (theta[1] < -20 | theta[1] > 20)\n      return(FALSE)\n    if (theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if (theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Weibull\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if (theta[2] <= 0 | theta[2] > 20)\n      return(FALSE)\n    if (theta[3] <= 0 | theta[3] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Log-logistic\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if (theta[2] < -20 | theta[2] > 20)\n      return(FALSE)\n    if (theta[3] <= 0 | theta[3] > 20)\n      return(FALSE)\n  }\n  else if (model == \"Mixture multistage\") {\n\n    # bounding for regression coef is same as in a multistage\n    # being less restrictive than EPA guidelines\n    if(theta[1] < -100 | theta[1] > 100)\n      return(FALSE)\n    if(theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if(theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n    if(theta[4] < -100 | theta[4] > 100)\n      return(FALSE)\n    if(theta[5] < -100 | theta[5] > 100)\n      return(FALSE)\n    if(theta[6] < 0 | theta[6] > 1)\n      return(FALSE)\n  }\n  else if (model == \"Hill\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if (theta[2] < -20 | theta[2] > 20)\n      return(FALSE)\n    if (theta[3] < -20 | theta[3] > 20)\n      return(FALSE)\n    if (theta[4] < 0 | theta[4] > 20)\n      return(FALSE)\n  }\n  else if (model == \"Multistage 1\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if(theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n\n  }\n  else if (model == \"Multistage 2\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if(theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if(theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Multistage 3\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if(theta[2] < -100 | theta[2] > 100)\n      return(FALSE)\n    if(theta[3] < -100 | theta[3] > 100)\n      return(FALSE)\n    if(theta[4] < -100 | theta[4] > 100)\n      return(FALSE)\n  }\n  else if (model == \"Probit\") {\n    if (theta[1] < -20 | theta[1] > 20)\n      return(FALSE)\n    if (theta[2] <= 0 | theta[2] > 20)\n      return(FALSE)\n  }\n  else if (model == \"Log-probit\") {\n    if (theta[1] < 0 | theta[1] >= 1)\n      return(FALSE)\n    if (theta[2] < -20 | theta[2] > 20)\n      return(FALSE)\n    if (theta[3] <= 0 | theta[3] > 20)\n      return(FALSE)\n  }\n\n  return(TRUE)\n\n}\n\n# plotting function for dose response model\n# model: string name of dose response model\n# theta: vector of model parameter values\n# limit: dose limit, will control how much of the dose response function is shown\n# log_dose: if true transform the x-axis\n# returns: a ggplot of the dose response function\nplot_response = function(model, theta, limit, log_dose = F) {\n\n  # generate dose levels\n  x = seq(0.01, limit, length.out=100)\n\n  # add additional resolution close to 0 to help with log transform\n  x = c(x, seq(.001, .1, length.out=20))\n\n  # compute response using appropriate model function\n  if (model == \"Logistic\")\n    y = 1/(1 + exp(-theta[1] - theta[2]*x))\n  else if (model == \"Log-logistic\")\n    y = theta[1] + (1-theta[1])/(1+exp(-theta[2]-theta[3]*log(x)))\n  else if (model == \"Weibull\")\n    y = theta[1] + (1 - theta[1])*(1 - exp(-theta[3]*x^theta[2]))\n  else if (model == \"Multistage 1\")\n    y = theta[1] + (1-theta[1])*(1-exp(-theta[2]*x))\n  else if (model == \"Multistage 2\")\n    y = theta[1] + (1-theta[1])*(1-exp(-theta[2]*x - theta[3]*x^2))\n  else if (model == \"Multistage 3\")\n    y = theta[1] + (1-theta[1])*(1-exp(-theta[2]*x - theta[3]*x^2 - theta[4]*x^3))\n  else if (model == \"Hill\")\n    y = theta[1] + (theta[2]-theta[2]*theta[1])/(1+exp(-theta[3]-theta[4]*log(x)))\n  else if (model == \"Logistic quadratic\")\n    y = 1/(1 + exp(-theta[1] - theta[2]*x - theta[3]*x^2))\n  else if (model == \"Logistic cubic\")\n    y = 1/(1 + exp(-theta[1] - theta[2]*x - theta[3]*x^2 - theta[4]*x^3))\n  else if (model == \"Logistic fractional polynomial\") {\n    powers = c(0, theta[4], theta[5])\n    eta = theta[1] + theta[2]*H(2, x, powers) + theta[4]*H(3, x, powers)\n    y = 1/(1+exp(-eta))\n  }\n  else if (model == \"Mixture multistage\")\n    y = theta[6]*(1-exp(-theta[1]-theta[2]*x-theta[3]*x^2)) + (1-theta[6])*(1-exp(-theta[1]-theta[4]*x - theta[5]*x^2))\n  else if (model == \"Probit\")\n    y = pnorm(theta[1] + theta[2]*x)\n  else if (model == \"Log-probit\")\n    y = theta[1] + (1-theta[1])*pnorm(theta[2] + theta[3]*log(x))\n  else if (model == \"4 parameter log-logistic\")\n    y = theta[1] + (theta[4] - theta[1])/(1 + exp(-theta[2] - theta[3]*log(x)))\n  else\n    y = x\n\n  # plot\n  # scaling dose\n  if (log_dose) {\n    xlabel = \"log dose\"\n    dose = log(x)\n  }\n  else {\n    xlabel = 'dose'\n    dose = x\n  }\n\n  p = ggplot2::ggplot(mapping = ggplot2::aes(y = y, x = dose)) +\n    ggplot2::geom_line(color = \"red\") +\n    ggplot2::geom_hline(yintercept = 0) +\n    ggplot2::theme_bw() +\n    ggplot2::labs(title = \"Dose response\") +\n    ggplot2::xlab(xlabel) +\n    ggplot2::ylab(\"P(dose)\")\n\n\n  return(p)\n}\n\n# checks if information matrix is invertible\n# returns 1 if invertible and 0 if not\n# can optimize easily for 2 dim\ncheckMinv = function(M) {\n\n  if (class(try(solve(M),silent=T))[1]!=\"matrix\")\n    return(0)\n  else\n    return(1)\n}\n\n# utility functions for fractional polynomials\n\n# Box-Tidwell transformation\nbt = function(X, p) {\n  if (p != 0)\n    return(X^p)\n  else if (p == 0)\n    return(suppressWarnings(log(X)))\n}\n\n# derivative of Box-Tidwell\ndbt = function(X, p) {\n  if (p != 0)\n    return(p * X^(p-1))\n  else if (p == 0)\n    return(1/X)\n}\n\n# H function\n# j: index\nH = function(j, X, powers) {\n  if (j == 1) # base case\n    return(1)\n  if (powers[j] != powers[j-1])\n    return(bt(X, powers[j]))\n  else if (powers[j] == powers[j-1])\n    return(suppressWarnings(log(X)) * H(j-1, X, powers))\n}\n\n# derivative of the H function\ndH = function(j, X, powers) {\n  if (j == 1) # base case\n    return(0)\n  if (powers[j] != powers[j-1])\n    return(dbt(X, powers[j]))\n  else if (powers[j] == powers[j-1])\n    return(suppressWarnings(log(X)) * dH(j-1, X, powers) +\n             H(j-1, X, powers)/X)\n}\n\n# calculates the fractional polynomial for given X, coefficients, powers\n# m: degree\nfracpoly = function(X, betas, powers, m) {\n\n  y = 0\n\n  for (j in 1:(m+1)) {\n    y = y + betas[j] * H(j, X, powers)\n  }\n\n  return(y)\n\n}\n\n# model selector\n# returns gradient function\ngrad_selector = function(model) {\n\n  if (model == \"Logistic\")\n    grad_fun = grad.logistic\n  else if (model == \"Logistic quadratic\")\n    grad_fun = grad.logistic.quad\n  else if (model == \"Logistic cubic\")\n    grad_fun = grad.logistic.cubic\n  else if (model == \"Logistic fractional polynomial\")\n    grad_fun = grad.logistic.fp\n  else if (model == \"Weibull\")\n    grad_fun = grad.weibull\n  else if (model == \"Log-logistic\")\n    grad_fun = grad.loglogistic\n  else if (model == \"Mixture multistage\")\n    grad_fun = grad.mix2\n  else if (model == \"Box-Cox Weibull\")\n    grad_fun = grad.boxcoxweibull\n  else if (model == \"Hill\")\n    grad_fun = grad.hill\n  else if (model == \"Multistage 1\")\n    grad_fun = grad.multi1\n  else if (model == \"Multistage 2\")\n    grad_fun = grad.multi2\n  else if (model == \"Multistage 3\")\n    grad_fun = grad.multi3\n  else if (model == \"Probit\")\n    grad_fun = grad.probit\n  else if (model == \"Log-probit\")\n    grad_fun = grad.logprobit\n  else if (model == \"4 parameter log-logistic\")\n    grad_fun = grad.loglogistic4\n\n  return(grad_fun)\n}\n\n################################################################################\n# gradient functions for BMD\n################################################################################\n# refer to the EPA's BMDS user manual for the original formulas\nbmdgrad.logistic.add = function(r, theta) {\n\n  beta0 = theta[1]\n  beta1 = theta[2]\n\n  g1 = r/(beta1 * (exp(beta0) + r))\n  g2 = suppressWarnings(-log(-(exp(beta0) * (r - 1))/(exp(beta0) +r)) / beta1^2)\n  return(c(g1, g2))\n}\n\nbmdgrad.logistic.extra = function(r, theta) {\n\n  beta0 = theta[1]\n  beta1 = theta[2]\n\n  g1 = (exp(beta0) + 1)*r*(exp(beta0)*(r+1)+r-1)/(beta1*(exp(beta0)*r+r-1)*(exp(beta0)*(r+1)+r))\n  g2 = suppressWarnings(- log(- (exp(beta0)*(exp(beta0)*r+r-1))/(exp(beta0)*(r+1)+r))/beta1^2)\n  return(c(g1, g2))\n\n}\n\nbmdgrad.weibull.add = function(r, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = suppressWarnings(r * (-log((g+r-1)/(g-1))/b)^(1/(a-1)) / (a*b*(g-1)*(g+r-1)))\n  g2 = suppressWarnings(-(log(-(log((g+r-1)/(g-1)))/b) * (-(log((g+r-1)/(g-1)))/b)^(1/a))/(a^2))\n  g3 = suppressWarnings(-(-log((g+r-1)/(g-1))/b)^(1/a)/(a * b))\n  return(c(g1, g2, g3))\n}\n\nbmdgrad.weibull.extra = function(r, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = 0\n  g2 = suppressWarnings(- log(-log(1-r)/b)*(-log(1-r)/b)^(1/a) / a^2)\n  g3 = suppressWarnings(- (-log(1-r)/b)^(1/a) / (a*b))\n  return(c(g1, g2, g3))\n}\n\nbmdgrad.loglogistic.add = function(r, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = exp(-a/b)*(-r/(g+r-1))^(1/(b+1)) / (b*r)\n  g2 = -exp(-a/b)*(-r/(g+r-1))^(1/b) / b\n  g3 = suppressWarnings(exp(-a/b)*(-r/(g+r-1))^(1/b) * (a - log(-r/(g+r-1))) / b^2)\n  return(c(g1, g2, g3))\n}\n\nbmdgrad.loglogistic.extra = function(r, theta) {\n\n  g = theta[1]\n  a = theta[2]\n  b = theta[3]\n\n  g1 = 0\n  g2 = suppressWarnings(-exp((log(r/(1-r))-a)/b)/b)\n  g3 = suppressWarnings(exp(-a/b) * (r/(1-r))^(1/b) * (a - log(r/(1-r))) / b^2)\n  return(c(g1,g2,g3))\n}\n\nbmdgrad.hill.add = function(r, theta) {\n\n  g = theta[1]\n  v = theta[2]\n  a = theta[3]\n  b = theta[4]\n\n  t1 = exp(-a/b)\n  t2 = ((g*r*v-g*v-r+v)/(r-g*r*v))^(-1/b)\n  t3 = r*(g*v-1)-g*v+v\n\n  g1 = (v-1)*v*t1*t2/(b*(g*v-1)*t3)\n  g2 = -(g-1)*t1*t2/(b*(g*v-1)*t3)\n  g3 = -t1*t2/b\n  g4 = suppressWarnings(-(-a-log((g*r*v-g*v-r+v)/(r*(1-g*v))))*(exp((-a-log((g*r*v-g*v-r+v)/(r-g*r*v)))/(b)))/(b^2))\n  return(c(g1, g2, g3, g4))\n\n}\n\nbmdgrad.hill.extra = function(r, theta) {\n\n  g = theta[1]\n  v = theta[2]\n  a = theta[3]\n  b = theta[4]\n\n  t1 = exp(-a/b)\n  t2 = (-(g*v+r-v)/(r))^(1/b)\n  t3 = b*((g-1)*v+r)\n\n  g1 = v*t1*t2/t3\n  g2 = (g-1)*t1*t2/t3\n  g3 = suppressWarnings(-exp((log(-(g*v+r-v)/r)-a)/b)/b)\n  g4 = t1*t2 * (a - log(-(g*v+r-v)/(r))) / (b^2)\n  return(c(g1,g2,g3,g4))\n\n}\n\n\n\n################################################################################\n# Run the application\n################################################################################\nshinyApp(ui = ui, server = server)\n\n","type":"text"},{"name":"SingleObjApp-shinylive.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n\nAutoAppendNewline: Yes\nStripTrailingWhitespace: Yes\n","type":"text"}]
